{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/2022-10-28-Connecting-api-uptime-monitoring-dashboard-and-Integrating-with-Kubernetes/","result":{"data":{"markdownRemark":{"excerpt":"Why? We put a lot of work and money into developing our APIs. We have tested it, tweaked it, and tested it some more. Everything works great during testing, and…","html":"<h2>Why?</h2>\n<p>We put a lot of work and money into developing our APIs. We have tested it, tweaked it, and tested it some more. Everything works great during testing, and the live version does well.</p>\n<p>Let’s face it, APIs fail for many reasons, so our investment in time needs to be protected. We owe it to the users of our API to ensure that it performs at optimum levels 24/7.</p>\n<p>We need to monitor our APIs because,</p>\n<ul>\n<li>It is OUR responsibility.</li>\n<li>Regular website monitoring may not capture API issues.</li>\n<li>Not every API method may be working.</li>\n<li>Reduced user satisfaction</li>\n</ul>\n<p>We can only be sure to conduct our own testing to protect our investment from third-party API failures.</p>\n<h2>Monitoring Dashboard: Statping</h2>\n<p>We decided to integrate statping for API monitoring.</p>\n<p>Statping is an easy to use Status Page for websites and applications. Statping will automatically fetch the application and render a status page.</p>\n<p><strong>Step 1: Adding the statping service in docker compose for development setup</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"yaml=\"><pre class=\"language-yaml=\"><code class=\"language-yaml=\">statping:\n  image: statping/statping:v0.90.74\n  restart: always\n  ports:\n    - &quot;8080:8080&quot;\n  volumes:\n    - ./docker/statping/app/config.yml:/app/config.yml\n    - ./docker/statping/app/services.yml:/app/services.yml\n  </code></pre></div>\n<p><strong>Step 2: Adding the custom config and services</strong></p>\n<p>Now, we have mounted two files which will contain our config and services for statping setup. These files <em>should</em> be present before the service startup in the mounted path.</p>\n<p>we can provide the configuartion for setup of statping. Read in detail <a href=\"https://github.com/statping/statping/wiki/config.yml\">here.</a></p>\n<p>Example <code class=\"language-text\">config.yml</code></p>\n<div class=\"gatsby-highlight\" data-language=\"yaml=\"><pre class=\"language-yaml=\"><code class=\"language-yaml=\">connection: sqlite3\nuser: &lt;username&gt;\npassword: &lt;password&gt;\ndatabase: statping\napi_secret: &lt;secret&gt;\nlanguage: en\nallow_reports: true\nlocation: /app \nsqlfile: /app/statping.db\ndisable_http: false\ndemo_mode: false\ndisable_logs: false\nuse_assets: false\nsample_data: false\nuse_cdn: false\ndisable_colors: false\nNAME: &lt;Name of the Project&gt;\nDESCRIPTION: Monitoring Dashboard</code></pre></div>\n<p>We can import multiple services when Statping first loads by creating a file named services.yml in the working directory for Statping. It will insert the new service into the database, and will not be re-added on reboot.</p>\n<p>Example: <code class=\"language-text\">service.yml</code></p>\n<div class=\"gatsby-highlight\" data-language=\"yaml=\"><pre class=\"language-yaml=\"><code class=\"language-yaml=\">services:\n  - name: &lt;Service Name&gt;\n    domain: {{host_url}}/ping\n    expected: Pong!\n    type: http\n    method: GET\n    headers: {{other_headers}},Authorization=Bearer {{token}}\n    port: 80\n    check_interval: 60\n    timeout: 15\n    expected_status: 200\n    allow_notifications: true\n    notify_after: 2\n    notify_all_changes: true\n    public: true\n    redirect: true</code></pre></div>\n<p>We have a python script which populates the services.yml with the required <code class=\"language-text\">host_url</code>, <code class=\"language-text\">headers</code>.</p>\n<p>Now we will move on to adding statping in our k8s cluster. We use <em>Kustomize</em> which is a standalone tool to customize Kubernetes objects through a kustomization file.</p>\n<p><strong>Step 3: Creating a Deployment for Statping in the cluster</strong></p>\n<p>A Deployment provides declarative updates for Pods and ReplicaSets.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml=\"><pre class=\"language-yaml=\"><code class=\"language-yaml=\">---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: statping\nspec:\n  replicas: 1\n  revisionHistoryLimit: 2\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 25%\n      maxUnavailable: 25%\n  template:\n    spec:\n      volumes:\n        - configMap:\n            name: statping-cfg\n          name: config\n      initContainers: []\n      containers:\n        - name: statping\n          image: hunterlong/statping:v0.90.74\n          volumeMounts:\n            - name: data\n              mountPath: /app\n            - name: config\n              mountPath: /app/config.yml\n              subPath: config.yml\n          ports:\n            - name: http\n              containerPort: 8080\n          envFrom:\n            - secretRef:\n                name: statping-creds\n          env:\n            - name: DOMAIN\n                value: https://$(DOMAIN)/status\n            - name: BASE_PATH\n                value: status</code></pre></div>\n<p><strong>Step 4: Creating a Ingress for Statping in the cluster</strong></p>\n<p>Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml=\"><pre class=\"language-yaml=\"><code class=\"language-yaml=\">---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: statping\n  annotations:\n    cert-manager.io/cluster-issuer: letsencrypt-production\nspec:\n  tls:\n    - hosts: [$(DOMAIN)]\n      secretName: statping-cert\n  rules:\n    - host: $(DOMAIN)\n      http:\n        paths:\n          - path: /status\n            pathType: Prefix\n            backend:\n              service:\n                name: statping\n                port:\n                  name: http</code></pre></div>\n<p><strong>Step 5: Creating a Service for Statping in the cluster</strong></p>\n<p>Service is an abstract way to expose an application running on a set of Pods as a network service.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml=\"><pre class=\"language-yaml=\"><code class=\"language-yaml=\">---\napiVersion: v1\nkind: Service\nmetadata:\n  name: statping\n  annotations:\n    prometheus.io/metrics_path: /status/metrics\nspec:\n  ports:\n    - name: http\n      port: 80\n      protocol: TCP\n      targetPort: http\n    - name: metrics\n      port: 9090\n      protocol: TCP\n      targetPort: http</code></pre></div>\n<p><strong>Step 6: Creating a ConfigMap and Secret for statping</strong></p>\n<p>A ConfigMap is an API object used to store non-confidential data in key-value pairs. Pods can consume ConfigMaps as environment variables, command-line arguments, or as configuration files in a volume.</p>\n<p>A ConfigMap allows you to decouple environment-specific configuration from your container images, so that your applications are easily portable.</p>\n<p>ConfigMaps and Secrets hold configuration or sensitive data that are used by other Kubernetes objects, such as Pods.</p>\n<p>The source of truth of ConfigMaps or Secrets are usually external to a cluster.</p>\n<p>Kustomize has secretGenerator and configMapGenerator, which generate Secret and ConfigMap from files or literals.</p>\n<p>To use a ConfigMap in a Deployment, reference it by the name of the configMapGenerator. Kustomize will automatically replace this name with the generated name.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml=\"><pre class=\"language-yaml=\"><code class=\"language-yaml=\">\nconfigMapGenerator:\n  - name: statping-globals\n    literals:\n      - DOMAIN=&lt;&gt;\n      - BACKUP_PATH=&lt;&gt;\n  - name: statping-s3-globals\n    literals:\n      - FILE_NAME=&lt;&gt;\n      - BUCKET_NAME=&lt;&gt;\n      - S3_HOST=&lt;&gt;\n      - STATPING_HOST_EXPORT_URL=&lt;&gt;\n      - STATPING_HOST_IMPORT_URL=&lt;&gt;\n</code></pre></div>\n<p>We have statping configured in our cluster and ready to be deployed.</p>\n<p>Now, we need to persist the data across pod restarts/failures. For acheiving that, we decided to go for a two way approach.</p>\n<p>We need to export the statping data on a regular interval that means implementing a cron job and import the data on pod restart that means implementing a side car for importing services just after the pod is up again.</p>\n<p><strong>Step 7: Adding a Cronjob for exporting the statping data</strong></p>\n<p>For the cronjob, we need a script that will export the services metadata with history and save it to S3 bucket. I created the script for export <a href=\"https://github.com/cern-sis/statping-s3/blob/main/export-services.py\">here</a>. Now after the script, I need to run as a cronjob which will run every hour to export the data and keep it updated.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml=\"><pre class=\"language-yaml=\"><code class=\"language-yaml=\">apiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: statping-export\nspec:\n  schedule: &#39;@hourly&#39;\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          restartPolicy: OnFailure\n          containers:\n            - name: statping-export\n              image: registry.cern.ch/cern-sis/statping-s3:v1.18.0\n              imagePullPolicy: IfNotPresent\n              args: [&#39;./export-services.py&#39;]\n              envFrom:\n                - secretRef:\n                    name: statping-creds\n                - secretRef:\n                    name: statping-s3-creds\n                - configMapRef:\n                    name: statping-s3-globals</code></pre></div>\n<p><strong>Step 8: Adding a sidecar for importing the statping data on Statping Pod Restart</strong></p>\n<p>This step was the challenging part and took most of the time since the import services is a script, and when the import is done, the Pod stops, both containers (Statping and the Import services sidecar) restart, and the container was reaching Backoff Limit. I created the script for import <a href=\"https://github.com/cern-sis/statping-s3/blob/main/import-services.py\">here</a>.</p>\n<p>The first way is to add <code class=\"language-text\">restartPolicy: OnFailure</code> to the container, but only <code class=\"language-text\">Always</code> is supported.</p>\n<p>Another way was to keep the script running endlessly, and it worked 🎉</p>\n<p>Below is the patch for adding sidecar container to the statping:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml=\"><pre class=\"language-yaml=\"><code class=\"language-yaml=\">- name: statping-import\n  image: registry.cern.ch/cern-sis/statping-s3:v1.18.0\n  args: [&#39;./import-services.py&#39;]\n  envFrom:\n    - secretRef:\n        name: statping-creds\n    - secretRef:\n        name: statping-s3-creds\n    - configMapRef:\n        name: statping-s3-globals</code></pre></div>\n<p>We have now reached the end of this blog and Statping is ready to tested on qa and deployed on Production environments.</p>\n<p>I personally learned a lot of things while intergrating the Statping dashboard. Thanks to Benjamin for helping me to understand Kubernetes concepts and actively answering to my questions.</p>","frontmatter":{"title":"Connecting API uptime monitoring dashboard and Integrating with Kubernetes","tags":["cern analysis preservation","blog","devops","monitoring","Parth Shandilya","2022"],"date":"October 28, 2022","description":"This is a test description for SEO and Open Graph purposes. If it's not provided, it defaults to auto-generated excerpts of the page content.","social_image":{"absolutePath":"/home/runner/work/blog/blog/static/media/rocket.jpg"}}},"prev":null,"next":null},"pageContext":{"slug":"/posts/2022-10-28-Connecting-api-uptime-monitoring-dashboard-and-Integrating-with-Kubernetes/","prevSlug":null,"nextSlug":null}},"staticQueryHashes":["2555585279","2714594843","3159585216"]}